use std::sync::Arc;

use fractional_index::FractionalIndex;
use loro_common::TreeID;
use rle::{HasLength, Mergable};
use serde::{Deserialize, Serialize};

use crate::state::TreeParentId;

/// The operation of movable tree.
///
/// In the movable tree, there are three actions:
/// - **Create**: target tree id will be generated by [`Transaction`], and parent tree id is `None`.
/// - **Move**: move target tree node a child node of the specified parent node.
/// - **Delete**: move target tree node to [`loro_common::DELETED_TREE_ROOT`].
///
///
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum TreeOp {
    Create {
        target: TreeID,
        parent: Option<TreeID>,
        position: FractionalIndex,
    },
    Move {
        target: TreeID,
        parent: Option<TreeID>,
        position: FractionalIndex,
    },
    Delete {
        target: TreeID,
    },
    EmptyTrash(Arc<Vec<TreeID>>),
}

impl TreeOp {
    pub(crate) fn target(&self) -> Option<TreeID> {
        match self {
            TreeOp::Create { target, .. }
            | TreeOp::Move { target, .. }
            | TreeOp::Delete { target, .. } => Some(*target),
            TreeOp::EmptyTrash(_) => None,
        }
    }
    pub(crate) fn parent_id(&self) -> Option<TreeParentId> {
        match self {
            TreeOp::Create { parent, .. } | TreeOp::Move { parent, .. } => {
                Some(TreeParentId::from(*parent))
            }
            TreeOp::Delete { .. } => Some(TreeParentId::Deleted),
            TreeOp::EmptyTrash(_) => None,
        }
    }
    pub(crate) fn fractional_index(&self) -> Option<FractionalIndex> {
        match self {
            TreeOp::Create { position, .. } | TreeOp::Move { position, .. } => {
                Some(position.clone())
            }
            TreeOp::Delete { .. } | TreeOp::EmptyTrash(_) => None,
        }
    }
}

impl HasLength for TreeOp {
    fn content_len(&self) -> usize {
        1
    }
}

impl Mergable for TreeOp {}
